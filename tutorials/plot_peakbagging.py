# Author: Dr. Enrico Corsaro# e-mail: enrico.corsaro@inaf.it# Date: June 2016# Modified: September 2019import sys, math, osimport pylab as plimport numpy as npimport glob def lorentzianProfile(freq0,amp0,gamma0,freq):    lorentzianProfile = amp0**2/(gamma0*np.pi) / (4*((freq - freq0)**2/(gamma0*gamma0)) + 1.0)    return lorentzianProfiledef readPowerspectrumTxt(kicID):    psdFile = glob.glob('data/KIC*{}*.txt'.format(kicID))[0]    # Array of two columns (freq,psd)    psd = np.loadtxt(psdFile).T        return psd    def readBackground(kicID):    bckGrdFile = glob.glob('results/KIC*{}*/backgroundParameters.txt'.format(kicID))[0]    backgroundParameters = np.loadtxt(bckGrdFile)    return backgroundParametersdef readNyquistFrequency(kicID):    nyqFile = glob.glob('results/KIC*{}*/NyquistFrequency.txt'.format(kicID))[0]    nyquistFrequency = np.loadtxt(nyqFile)    return nyquistFrequencydef readFrequencyRange(kicID,chunkID):    freqRangeFile = glob.glob('results/KIC*{}*/pb/frequencyRange_{}.txt'.format(kicID,chunkID))[0]    frequencyRange = np.loadtxt(freqRangeFile)    return frequencyRangedef readPriorHyperParameters(kicID,chunkID):    resolvedPriorFile = glob.glob('results/KIC*{}*/pb/prior_hyperParameters_{}.txt'.format(kicID,chunkID))[0]    resolvedPriorParameters = np.loadtxt(resolvedPriorFile).T    resolvedPriorParametersLowerBound = resolvedPriorParameters[0]    resolvedPriorParametersUpperBound = resolvedPriorParameters[1]    # Get the number of parameters and the number of associated peaks    n_resolved_par = len(resolvedPriorParametersLowerBound)     n_resolved = n_resolved_par/3    n_par = [n_resolved_par,n_resolved]        return n_pardef creatingBackgroundModel(psd,nyq,backgroundParameters):     freq,psd = psd    n_elements_freq = len(freq)    freq_new = np.arange(n_elements_freq*10,dtype=np.float)    freq_new = freq_new/max(freq_new) * (max(freq) - min(freq)) + min(freq)    zeta = 2.*np.sqrt(2.)/np.pi # !DPI is the pigreca value in double precision        r = (np.sin(np.pi/2. * freq_new/nyq) / (np.pi/2. * freq_new/nyq))**2 #; responsivity (apodization) as a sinc^2    w = backgroundParameters[0] # White noise component    ## Long-trend variations    sigma_long = backgroundParameters[1]    freq_long = backgroundParameters[2]    h_long = (sigma_long**2/freq_long) / (1. + (freq_new/freq_long)**4)    ## First granulation component    sigma_gran1 = backgroundParameters[3]    freq_gran1 = backgroundParameters[4]    h_gran1 = (sigma_gran1**2/freq_gran1) / (1. + (freq_new/freq_gran1)**4)    ## Second granulation component    sigma_gran2 = backgroundParameters[5]    freq_gran2 = backgroundParameters[6]    h_gran2 = (sigma_gran2**2/freq_gran2) / (1. + (freq_new/freq_gran2)**4)    ## Global background model    w = np.zeros_like(freq_new) + w    backgroundLevel = zeta*(h_long + h_gran1 + h_gran2)*r + w    backgroundModel = [backgroundLevel,r]     return backgroundModeldef readPeakBagging(kicID,chunkID):    pkBagFile = glob.glob('results/KIC*{}*/pb/*{}*/peakbagging_parameterSummary.txt'.format(kicID,chunkID))[0]    peakbaggingParameters = np.loadtxt(pkBagFile).T    par_median = peakbaggingParameters[1] #median values    par_le = peakbaggingParameters[4]     #lower credible limits    par_ue = peakbaggingParameters[5]     #upper credible limits    peakbaggingParameters = np.vstack((par_median,par_le,par_ue))    return peakbaggingParametersdef creatingPeakBaggingModel(psd,frequencyRange,backgroundModel,peakbaggingParameters,n_par):     freq,psd = psd    n_elements_freq = len(freq)    freq_new = np.arange(n_elements_freq*10,dtype=np.float)    freq_new = freq_new/max(freq_new) * (max(freq) - min(freq)) + min(freq)    prediction = np.zeros_like(freq_new)    mode_profile = np.zeros_like(freq_new)    par_median = peakbaggingParameters[0]    n_resolved = n_par[1]    n_resolved_par = n_par[0]    n_peaks = n_resolved    freq_fit = np.zeros(n_peaks)    freq_res = freq[1]-freq[0]    # Initialize Lorentzian profiles    for ii in range(0,n_resolved):        freq0 = par_median[ii*3]        amp0 = par_median[ii*3 + 1]        gamma0 = par_median[ii*3 + 2]        mode_profile = amp0**2/(gamma0*np.pi) / (4*((freq_new - freq0)**2/(gamma0*gamma0)) + 1.0)         prediction += mode_profile        freq_fit[ii] = freq0    peakbaggingPrediction = prediction*backgroundModel[1] + backgroundModel[0]    peakbaggingModel = [peakbaggingPrediction,freq_fit]    return peakbaggingModeldef readMarginalDistributions(kicID,chunkID,peakbaggingParameters,n_par):    par_median,par_le,par_ue = peakbaggingParameters    labelxResolved = ['Frequency ($\mu$Hz)','A (ppm)','$\Gamma$ ($\mu$Hz)']    n_resolved_par = n_par[0]    n_resolved = n_par[1]    print 'N resolved peaks:', n_resolved    pl.figure(figsize=(18,12))    for iii in range(0,9):        mpFile = glob.glob('results/KIC*{}*/pb/*{}*/peakbagging_marginalDistribution*{}.txt'.format(kicID,chunkID,iii))[0]                    par, marg = np.loadtxt(mpFile).T        pl.subplot(3,3,iii+1)        par_err_le = par_median[iii] - par_le[iii]        par_err_ue = par_ue[iii] - par_median[iii]        par_err = (par_err_le**2 + par_err_ue**2)**(0.5)/2**(0.5)        pl.xlim([par_median[iii]-5*par_err,par_median[iii]+5*par_err])        pl.ylim([0,max(marg)*1.2])        pl.plot(par, marg,linewidth=2,c='k')        pl.fill_between(par[(par >= par_le[iii]) & (par <= par_ue[iii])],                        marg[(par >= par_le[iii]) & (par <= par_ue[iii])],0,alpha=0.5,facecolor='green')        pl.tight_layout()        pl.axvline(par_median[iii],c='r')        pl.xticks(fontsize=10)  ;pl.yticks(fontsize=10)        parameter = iii % 3        pl.xlabel(labelxResolved[parameter],fontsize=9)        pl.ylabel('MPD',fontsize=9)    pl.figure(figsize=(18,12))    for iii in range(9,18):        mpFile = glob.glob('results/KIC*{}*/pb/*{}*/peakbagging_marginalDistribution*{}.txt'.format(kicID,chunkID,iii))[0]                    par, marg = np.loadtxt(mpFile).T        pl.subplot(3,3,iii-9+1)        par_err_le = par_median[iii] - par_le[iii]        par_err_ue = par_ue[iii] - par_median[iii]        par_err = (par_err_le**2 + par_err_ue**2)**(0.5)/2**(0.5)        pl.xlim([par_median[iii]-5*par_err,par_median[iii]+5*par_err])        pl.ylim([0,max(marg)*1.2])        pl.plot(par, marg,linewidth=2,c='k')        pl.fill_between(par[(par >= par_le[iii]) & (par <= par_ue[iii])],                        marg[(par >= par_le[iii]) & (par <= par_ue[iii])],0,alpha=0.5,facecolor='green')        pl.tight_layout()        pl.axvline(par_median[iii],c='r')        pl.xticks(fontsize=10)  ;pl.yticks(fontsize=10)        parameter = iii % 3        pl.xlabel(labelxResolved[parameter],fontsize=9)        pl.ylabel('MPD',fontsize=9)        pl.figure(figsize=(18,12))    for iii in range(18,27):        mpFile = glob.glob('results/KIC*{}*/pb/*{}*/peakbagging_marginalDistribution*{}.txt'.format(kicID,chunkID,iii))[0]                    par, marg = np.loadtxt(mpFile).T        pl.subplot(3,3,iii-18+1)        par_err_le = par_median[iii] - par_le[iii]        par_err_ue = par_ue[iii] - par_median[iii]        par_err = (par_err_le**2 + par_err_ue**2)**(0.5)/2**(0.5)        pl.xlim([par_median[iii]-5*par_err,par_median[iii]+5*par_err])        pl.ylim([0,max(marg)*1.2])        pl.plot(par, marg,linewidth=2,c='k')        pl.fill_between(par[(par >= par_le[iii]) & (par <= par_ue[iii])],                        marg[(par >= par_le[iii]) & (par <= par_ue[iii])],0,alpha=0.5,facecolor='green')        pl.tight_layout()        pl.axvline(par_median[iii],c='r')        pl.xticks(fontsize=10)  ;pl.yticks(fontsize=10)        parameter = iii % 3        pl.xlabel(labelxResolved[parameter],fontsize=9)        pl.ylabel('MPD',fontsize=9)    pl.figure(figsize=(18,12))    for iii in range(27,36):        mpFile = glob.glob('results/KIC*{}*/pb/*{}*/peakbagging_marginalDistribution*{}.txt'.format(kicID,chunkID,iii))[0]                    par, marg = np.loadtxt(mpFile).T        pl.subplot(3,3,iii-27+1)        par_err_le = par_median[iii] - par_le[iii]        par_err_ue = par_ue[iii] - par_median[iii]        par_err = (par_err_le**2 + par_err_ue**2)**(0.5)/2**(0.5)        pl.xlim([par_median[iii]-5*par_err,par_median[iii]+5*par_err])        pl.ylim([0,max(marg)*1.2])        pl.plot(par, marg,linewidth=2,c='k')        pl.fill_between(par[(par >= par_le[iii]) & (par <= par_ue[iii])],                        marg[(par >= par_le[iii]) & (par <= par_ue[iii])],0,alpha=0.5,facecolor='green')        pl.tight_layout()        pl.axvline(par_median[iii],c='r')        pl.xticks(fontsize=10)  ;pl.yticks(fontsize=10)        parameter = iii % 3        pl.xlabel(labelxResolved[parameter],fontsize=9)        pl.ylabel('MPD',fontsize=9)def plotPSD(psd,backgroundModel,peakbaggingModel,frequencyRange,n_par):    freq,psd = psd    pl.figure(figsize=(16,7))    peakbaggingPrediction = peakbaggingModel[0]    freq_fit = peakbaggingModel[1]    n_elements_freq = len(freq)    freq_new = np.arange(n_elements_freq*10,dtype=np.float)    freq_new = freq_new/max(freq_new) * (max(freq) - min(freq)) + min(freq)    pl.plot(freq,psd,color='0.3')    pl.plot(freq_new,backgroundModel[0],'b',linestyle='dashed',linewidth=2)    pl.plot(freq_new,backgroundModel[0]*8,'b',linestyle='dashed',linewidth=1)    pl.plot(freq_new,peakbaggingPrediction,'r',linestyle='solid',linewidth=2)    pl.xlim(frequencyRange[0],frequencyRange[1])    pl.ylim(min(psd*0.95),max(peakbaggingPrediction)*2.5)    pl.xticks(fontsize=16)  ;pl.yticks(fontsize=16)    pl.xlabel(r'Frequency [$\mu$Hz]',fontsize=18)    pl.ylabel(r'PSD [ppm$^2$/$\mu$Hz]',fontsize=18)    n_peaks = n_par[2] + n_par[3]    for i in range(0,n_peaks):        pl.plot([freq_fit[i],freq_fit[i]],[0,max(psd)],'k',linestyle='dotted',linewidth=1)if __name__ == "__main__":     os.system('clear')    kicID = '12008916'    chunkID = '0'    psd = readPowerspectrumTxt(kicID)    backgroundParameters = readBackground(kicID)    frequencyRange = readFrequencyRange(kicID,chunkID)    n_par = readPriorHyperParameters(kicID,chunkID)    nyquistFrequency = readNyquistFrequency(kicID)    backgroundModel = creatingBackgroundModel(psd,nyquistFrequency,backgroundParameters)    peakbaggingParameters = readPeakBagging(kicID,chunkID)    peakbaggingModel = creatingPeakBaggingModel(psd,frequencyRange,backgroundModel,peakbaggingParameters,n_par)    print 'Frequency Range (microHz):', frequencyRange    print 'Nyquist Frequency (microHz):', nyquistFrequency    readMarginalDistributions(kicID,chunkID,peakbaggingParameters,n_par)        plotPSD(psd,backgroundModel,peakbaggingModel,frequencyRange,n_par)    pl.show()    